server.message=I am a dev server

package com.example.core.service;

import lombok.SneakyThrows;
import lombok.extern.java.Log;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.util.concurrent.ListenableFuture;
import org.springframework.util.concurrent.ListenableFutureCallback;
import org.springframework.web.client.AsyncRestTemplate;
import org.springframework.web.context.request.async.AsyncRequestTimeoutException;
import org.springframework.web.context.request.async.DeferredResult;

import java.util.Arrays;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

/*
    * 대외거래 설계방안
      1. 지연응답, 무응답 등의 이유로 Async 사용.
      2. (Async) RestTemplate으로 HTTP 요청 및 응답 정상/오류 식별
         >> Spring WebFlux .. WebClient도 좋은 방안일듯
      3. 지연응답 조치 : Long Polling( Request Timeout 설정 후 DeferredResult 사용 )
                     >> 스트리밍도 좋은 방안일듯
      4. 무응답 조치 : Request Timeout 설정.
                    하지만 Long Polling 되고 있으므로, 계속 기다릴 수 없으니 이것 또한 특정 시간 연결 해제하면 됨
      5. 추가로 Timeout 발생 시, 한 번 더 요청
         >> 추후 요청자와 응답자 데이터 정합성을 위해 시그널을 줘야 함

Transport Layer(전송 계층) packet loss 해결 방안
Timeout 조치 방안 .. keep alive > polling / streaming
http status code, connection / disconnection
thread pool과 기존 thread 활용방안
>> 추가로 계속 연결상태이니 밍연결을 어떻게 해제할 지 방안 강구해야 함
 */
@Service
@Log
public class ExternalCardService {

    public DeferredResult<String> getYN(boolean exit) throws ExecutionException, InterruptedException, TimeoutException, AsyncRequestTimeoutException {
        AsyncRestTemplate restTemplate = new AsyncRestTemplate();
        String baseUrl = "http://localhost:8092/card/nothing";
        HttpHeaders requestHeaders = new HttpHeaders();
        requestHeaders.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));
        HttpEntity entity = new HttpEntity("parameters", requestHeaders);

        // DeferredResult : 초기화 및 Timeout 설정
        final DeferredResult<String> dfresult = new DeferredResult<>(5000L);

        // AsyncRestTemplate : HTTP 요청
        ListenableFuture<ResponseEntity<String>> futureEntity = restTemplate.getForEntity(baseUrl, String.class);

        // ListenableFuture : HTTP 응답 처리
        futureEntity.addCallback(new ListenableFutureCallback<ResponseEntity<String>>() {
            @Override
            public void onSuccess(ResponseEntity<String> result) { // 성공
                log.info(result.getBody());
                dfresult.setResult(result.getBody()); // 지연 응답 처리
            }

            @Override
            public void onFailure(Throwable ex) { // 실패
                log.info(ex.getMessage());
                dfresult.setErrorResult(ex.getMessage()); // 지연 응답 처리
            }
        });

        // DeferredResult : Timeout 처리
        dfresult.onTimeout(new Runnable() {
            @SneakyThrows
            /*
                Runnable의 run() 메소드 안에서 발생한 예외는 호출한 쓰레드로 제대로 전파되지 않는다.
                모든 예외가 RuntimeException으로 묶여 던져지기 때문에(심지어 예외 메시지가 비어있는 경우도 있다)
                정상적인 예외 처리를 할 수 없는데, 이러한 경우 @SneakyThrows가 유용하게 사용된다.
             */
            @Override
            public void run() {
                dfresult.setErrorResult(
                        ResponseEntity.status(HttpStatus.REQUEST_TIMEOUT)
                                .body("[ Timeout ]"));

                if(!exit) {
                    getYN(true); // Timeout 시, 한 번 더 요청
                }
            }
//            dfresult.onTimeout(() ->
//                dfresult.setErrorResult(
//                        ResponseEntity.status(HttpStatus.REQUEST_TIMEOUT)
//                                .body("Request timeout occurred.")));

        });

        return dfresult;
    }
}
